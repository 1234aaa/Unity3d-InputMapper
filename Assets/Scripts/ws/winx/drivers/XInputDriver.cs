//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.17929
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using ws.winx.platform;
using System.Runtime.InteropServices;
using ws.winx.devices;
using UnityEngine;



namespace ws.winx.drivers
{
    public class XInputDriver : IDriver
    {

      
//        IHIDInterface _hidInterface;
        int _lastFrameNum = -1;
    

        private const float XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE = 0.239f;//7849;
        private const float XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE = 0.265f;//8689
        private const float XINPUT_GAMEPAD_TRIGGER_THRESHOLD = 0.117f;// 30;
        private const float ERROR_SUCCESS = 0;


        public enum XTYPE : int
        {
            XBOX = 0,
            XBOX360,
            XBOX360W
        }


       /// <summary>
       /// 
       /// </summary>
        public XInputDriver()
        {
           

        }

        int[] XPAD_DEVICE = new int[] {
                 0x045e, 0x02A1, /*My XBOX test Xbox 360 Wireless Receiver */(int)XTYPE.XBOX360W,
 	             0x045e, 0x0202, /* "Microsoft X-Box pad v1 (US)",0*/  (int)XTYPE.XBOX ,
	             0x045e, 0x0289, /* "Microsoft X-Box pad v2 (US)", 0*/ (int)XTYPE.XBOX ,
 	             0x045e, 0x0285,  /*"Microsoft X-Box pad (Japan)", 0*/ (int)XTYPE.XBOX ,
 	             0x045e, 0x0287,  /*"Microsoft Xbox Controller S", 0*/(int) XTYPE.XBOX ,
	             0x045e, 0x0289,  /*"Microsoft X-Box pad v2 (US)", 0*/ (int)XTYPE.XBOX ,
	             0x045e, 0x028e, /*Microsoft X-Box 360 pad", 0,*/ (int)XTYPE.XBOX360, 
	             0x045e, 0x0291,/*Xbox 360 Wireless Receiver (XBOX)", MAP_DPAD_TO_BUTTONS*/(int) XTYPE.XBOX360W ,
 	             0x045e, 0x0719,/*Xbox 360 Wireless Receiver", MAP_DPAD_TO_BUTTONS*/(int) XTYPE.XBOX360W ,
	             0x0c12, 0x8809,/*RedOctane Xbox Dance Pad", DANCEPAD_MAP_CONFIG*/ (int)XTYPE.XBOX, 
 	             0x044f, 0x0f07,/*Thrustmaster, Inc. Controller", 0*/ (int)XTYPE.XBOX ,
 	             0x046d, 0xc242,/*Logitech Chillstream Controller", 0*/ (int)XTYPE.XBOX360 ,
 	             0x046d, 0xca84,/*Logitech Xbox Cordless Controller", 0*/ (int)XTYPE.XBOX ,
 	             0x0738, 0x4540,/*Mad Catz Beat Pad", MAP_DPAD_TO_BUTTONS*/ (int)XTYPE.XBOX ,
 	             0x0738, 0x4556,/*Mad Catz Lynx Wireless Controller", 0*/ (int)XTYPE.XBOX ,
 	             0x0738, 0x4716,/*Mad Catz Wired Xbox 360 Controller", */ (int)XTYPE.XBOX360 ,
	             0x0738, 0x4728,/*Mad Catz Street Fighter IV FightPad", XTYPE_XBOX360 
 	             0x0738, 0x4738,/*Mad Catz Wired Xbox 360 Controller (SFIV)", MAP_TRIGGERS_TO_BUTTONS,*/ (int)XTYPE.XBOX360 ,
 	             0x0738, 0x6040,/*Mad Catz Beat Pad Pro", MAP_DPAD_TO_BUTTONS,*/ (int)XTYPE.XBOX, 
	             0x0738, 0xbeef,/*Mad Catz JOYTECH NEO SE Advanced GamePad",*/ (int)XTYPE.XBOX360 ,
 	             0x0c12, 0x8802,/*Zeroplus Xbox Controller", */ (int)XTYPE.XBOX, 
	             0x0c12, 0x8809,/*RedOctane Xbox Dance Pad", DANCEPAD_MAP_CONFIG,*/ (int)XTYPE.XBOX, 
 	             0x0c12, 0x880a,/*Pelican Eclipse PL-2023", */ (int)XTYPE.XBOX, 
 	             0x0c12, 0x8810,/*Zeroplus Xbox Controller", */ (int)XTYPE.XBOX, 
 	             0x0c12, 0x9902,/*HAMA VibraX - *FAULTY HARDWARE*", */ (int)XTYPE.XBOX, 
 	             0x0e6f, 0x0003,/*Logic3 Freebird wireless Controller", */ (int)XTYPE.XBOX, 
 	             0x0e6f, 0x0005,/*Eclipse wireless Controller", */ (int)XTYPE.XBOX, 
 	             0x0e6f, 0x0006,/*Edge wireless Controller", */ (int)XTYPE.XBOX, 
	             0x0e6f, 0x0006,/*Pelican 'TSZ' Wired Xbox 360 Controller", */ (int)XTYPE.XBOX360 ,
	             0x0e6f, 0x0105,/*HSM3 Xbox360 dancepad", MAP_DPAD_TO_BUTTONS,*/ (int)XTYPE.XBOX360 ,
 	             0x0e6f, 0x0201,/*Pelican PL-3601 'TSZ' Wired Xbox 360 Controller", */ (int)XTYPE.XBOX360 ,
	             0x0e6f, 0x0213,/*Afterglow Gamepad for Xbox 360", */ (int)XTYPE.XBOX360 ,
 	             0x0e8f, 0x0201,/*SmartJoy Frag Xpad/PS2 adaptor", */ (int)XTYPE.XBOX, 
	             0x0f0d, 0x000d,/*Hori Fighting Stick EX2", MAP_TRIGGERS_TO_BUTTONS,*/ (int)XTYPE.XBOX360 ,
	             0x0f0d, 0x0016,/*Hori Real Arcade Pro.EX", MAP_TRIGGERS_TO_BUTTONS, */(int)XTYPE.XBOX360 ,
 	             0x0f30, 0x0202,/*Joytech Advanced Controller", */ (int)XTYPE.XBOX, 
 	             0x0f30, 0x8888,/*BigBen XBMiniPad Controller", */ (int)XTYPE.XBOX, 
 	             0x102c, 0xff0c,/*Joytech Wireless Advanced Controller", */ (int)XTYPE.XBOX, 
	             0x12ab, 0x8809,/*Xbox DDR dancepad", MAP_DPAD_TO_BUTTONS, */(int)XTYPE.XBOX, 
 	             0x12ab, 0x0004,/*Honey Bee Xbox360 dancepad", MAP_DPAD_TO_BUTTONS,*/ (int)XTYPE.XBOX360 ,
	             0x0e6f, 0x0105,/*HSM3 Xbox360 dancepad", MAP_DPAD_TO_BUTTONS,*/ (int)XTYPE.XBOX360 ,
	             0x12ab, 0x8809,/*Xbox DDR dancepad", MAP_DPAD_TO_BUTTONS,*/ (int)XTYPE.XBOX, 
 	             0x1430, 0x4748,/*RedOctane Guitar Hero X-plorer", */ (int)XTYPE.XBOX360 ,
 	             0x1430, 0x8888,/*TX6500+ Dance Pad (first generation)", MAP_DPAD_TO_BUTTONS, (int)XTYPE.XTYPE_XBOX, 
 	             0x146b, 0x0601,/*BigBen Interactive XBOX 360 Controller", */ (int)XTYPE.XBOX360 ,
	             0x045e, 0x028e,/*Microsoft X-Box 360 pad", */ (int)XTYPE.XBOX360 ,
	             0x1689, 0xfd00,/*Razer Onza Tournament Edition", MAP_DPAD_TO_BUTTONS,*/ (int)XTYPE.XBOX360 ,
 	             0x1bad, 0x0002,/*Harmonix Rock Band Guitar", */ (int)XTYPE.XBOX360 ,
 	             0x1bad, 0x0003,/*Harmonix Rock Band Drumkit", MAP_DPAD_TO_BUTTONS, */(int)XTYPE.XBOX360 ,
	             0x0f0d, 0x0016,/*Hori Real Arcade Pro.EX", MAP_TRIGGERS_TO_BUTTONS,*/ (int)XTYPE.XBOX360 ,
	             0x0f0d, 0x000d,/*Hori Fighting Stick EX2", MAP_TRIGGERS_TO_BUTTONS, */(int)XTYPE.XBOX360 ,
	             0x1689, 0xfd00,/*Razer Onza Tournament Edition", MAP_DPAD_TO_BUTTONS,*/ (int)XTYPE.XBOX360 ,
	             0x1bad, 0xf016,/*Mad Catz Xbox 360 Controller", */ (int)XTYPE.XBOX360 ,
	             0x1bad, 0xf028,/*Street Fighter IV FightPad", */ (int)XTYPE.XBOX360 ,
	             0x1bad, 0xf901,/*Gamestop Xbox 360 Controller", */ (int)XTYPE.XBOX360 ,
	             0x1bad, 0xf903,/*Tron Xbox 360 controller", */ (int)XTYPE.XBOX360 ,
	             0x24c6, 0x5300,/*PowerA MINI PROEX Controller", */ (int)XTYPE.XBOX360 ,
 	             0xffff, 0xffff,/*Chinese-made Xbox Controller", */ (int)XTYPE.XBOX
                 
 	            
 };
        private IHIDInterface _hidInterface;







        #region IJoystickDriver implementation

        public void Update(IDevice device)
        //public void Update (IDevice<ws.winx.devices.IAxisDetails, ws.winx.devices.IButtonDetails, ws.winx.devices.IDeviceExtension> joystick)
        {
          


            //don't update in same frame twice
            if (_lastFrameNum == Time.frameCount)
                return;
            else _lastFrameNum = Time.frameCount;


            if (device.isReady)
            {
                ((JoystickDevice)device).isReady = false;
                _hidInterface.Read(device, onRead);
            }

        
           


        }


        void onRead(object data)
        {
            HIDReport report = data as HIDReport;
             IDevice device = _hidInterface.Devices[report.index];
          

            UnityEngine.Debug.Log(BitConverter.ToString(report.Data));
            if(report.Status==HIDReport.ReadStatus.Success){
              
                byte[] buff = report.Data;

            //C3-85-47-7B-2A-76-6D-7A-00-80-00-80-00-8E

        

            //controlTransfer(0x21, 0x09, 0x0240, 0, __outputBuffer, __outputBuffer.length, 0) > -1;

            //pad are last three bytes  (demo left click)
            //    82-81-47-7B-2A-76-6D-7A-00-80-00-9C-00-8E
            //    82-81-47-7B-2A-76-6D-7A-00-80-00-80-10-D0
            //    82-81-47-7B-2A-76-6D-7A-00-80-00-9C-80-E6
            //    82-81-47-7B-2A-76-6D-7A-00-80-00-80-00-8E





            ///////////////////////////////////// BUTTONS ////////////////////////////////////////
                device.Buttons[0].value = (buff[11] & 0x80) != 0 ? 1f : 0f;//Start
                device.Buttons[1].value =  (buff[11] & 0x40) != 0 ? 1f : 0f;//Back
                device.Buttons[2].value = (buff[11] & 0x10) != 0 ? 1f : 0f;//LThumb
                device.Buttons[3].value = (buff[11] & 0x20) != 0 ? 1f : 0f;//RThumb
                //device.Buttons[4].value = (float)(gamePad.dwButtons & (ushort)ButtonsFlags.XINPUT_GAMEPAD_LEFT_SHOULDER);
                //device.Buttons[5].value = (float)(gamePad.dwButtons & (ushort)ButtonsFlags.XINPUT_GAMEPAD_RIGHT_SHOULDER);



            ////byte 10 

            device.Buttons[6].value = (buff[11] & 0x01) != 0 ? 1f : 0f;//A
            device.Buttons[7].value = (buff[11] & 0x02) != 0 ? 1f : 0f;//B
            device.Buttons[8].value = (buff[11] & 0x04) != 0 ? 1f : 0f;//X
            device.Buttons[9].value = (buff[11] & 0x08) != 0 ? 1f : 0f;//Y


            // 80   1000 0000 -neutral
            // 84   1000 0100       Y+
            // 9C   1001 1100        X-
            // AO   1010 0000 LT
            // 8C   1000 1100  X+
            // 94   1001 0100  Y-
             //88  1000 1000
            // 90   1001 0000  RB
            // 98   1001 1000 LB
            // 88    1000 1000 RT



            ////byte 11,12,13

            //    //////////////////////////////  POV ////////////////////////////////////////
            //    float x = 0, y = 0;

            //    if ((gamePad.dwButtons & (ushort)ButtonsFlags.XINPUT_GAMEPAD_DPAD_UP) != 0) y = 1;
            //    else if ((gamePad.dwButtons & (ushort)ButtonsFlags.XINPUT_GAMEPAD_DPAD_DOWN) != 0) y = -1;

            //    if ((gamePad.dwButtons & (ushort)ButtonsFlags.XINPUT_GAMEPAD_DPAD_LEFT) != 0) x = -1;
            //    else if ((gamePad.dwButtons & (ushort)ButtonsFlags.XINPUT_GAMEPAD_DPAD_RIGHT) != 0) x = 1;

            //    device.Axis[JoystickAxis.AxisPovX].value = x;
            //    device.Axis[JoystickAxis.AxisPovY].value = y;




            //    ////////////////////////// AXIS //////////////////////////////////

            ////0-3 bytes left joystick
            ////4-8 bytes right joystick
            IAxisDetails axisDetails;
            float value;
           

            value=(buff[1] | (buff[2] << 8));
            UnityEngine.Debug.Log("valueX=" + value);
            axisDetails = device.Axis[JoystickAxis.AxisX];
            axisDetails.value = NormalizeAxis(value, axisDetails.min, axisDetails.max);
            UnityEngine.Debug.Log("valueX=" + axisDetails.value);

            value = axisDetails.max-(buff[3] | (buff[4] << 8));
            UnityEngine.Debug.Log("valueY=" + value);
            axisDetails = device.Axis[JoystickAxis.AxisY];
            axisDetails.value = NormalizeAxis(value, axisDetails.min, axisDetails.max);
            UnityEngine.Debug.Log("valueY=" + axisDetails.value);


            value = (buff[5] | (buff[6] << 8));
            axisDetails = device.Axis[JoystickAxis.AxisZ];
            axisDetails.value = NormalizeAxis(value, axisDetails.min, axisDetails.max);

            value = axisDetails.max-(buff[7] | (buff[8] << 8));
            axisDetails = device.Axis[JoystickAxis.AxisR];
            axisDetails.value = NormalizeAxis(value, axisDetails.min, axisDetails.max);



                //byte 9,10 (triggerL 80-FF  and triggerR 80 -00)
            //axisDetails = device.Axis[JoystickAxis.AxisU];
            //axisDetails.value = NormalizeAxis((float)gamePad.bLeftTrigger, axisDetails.min, axisDetails.max);

            //axisDetails = device.Axis[JoystickAxis.AxisV];
            //axisDetails.value = NormalizeAxis((float)gamePad.bRightTrigger, axisDetails.min, axisDetails.max);

            }










         //  // SetLed((XInputDevice)device, 0x1);
         //   SetMotor((XInputDevice)device, 0xff, 0xff);

            ((JoystickDevice)device).isReady = true;
         ////   device.Write(new byte[] { 0x00, 0x01, 0x0f, 0xc0, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00 });

          }

        public IDevice ResolveDevice(IHIDDevice hidDevice)
        //public IDevice<IAxisDetails, IButtonDetails, IDeviceExtension> ResolveDevice(IHIDDeviceInfo info)
        {
            int type = -1;
            int len = XPAD_DEVICE.Length;
            for (int i = 0; i < len; i += 3)
            {
                if (hidDevice.VID == XPAD_DEVICE[i] && hidDevice.PID == XPAD_DEVICE[i + 1])
                {
                    type = XPAD_DEVICE[i + 2];
                    break;
                }
            }

            if (type < 0) return null;

            XInputDevice device;
            int inx = 0;

           _hidInterface = hidDevice.hidInterface;
           


            device = new XInputDevice(hidDevice.index, hidDevice.PID, hidDevice.VID, 8, 10, this, type);


            //inti button structure
            for (; inx < 10; inx++)
            {
                device.Buttons[inx] = new ButtonDetails();
            }



            AxisDetails axisDetails;

            //LX
            axisDetails = new AxisDetails();
            axisDetails.max = 65535;
            axisDetails.min = 0;
            device.Axis[JoystickAxis.AxisX] = axisDetails;

            //LY
            axisDetails = new AxisDetails();
            axisDetails.max = 65535;
            axisDetails.min = 0;
            device.Axis[JoystickAxis.AxisY] = axisDetails;

            //RX
            axisDetails = new AxisDetails();
            axisDetails.max = 65535;
            axisDetails.min = 0;
            device.Axis[JoystickAxis.AxisZ] = axisDetails;

            //RY
            axisDetails = new AxisDetails();
            axisDetails.max = 65535;
            axisDetails.min = 0;
            device.Axis[JoystickAxis.AxisR] = axisDetails;


            //TRIGGERS
            axisDetails = new AxisDetails();
            axisDetails.max = 255;
            axisDetails.min = 0;
            device.Axis[JoystickAxis.AxisU] = axisDetails;

            axisDetails = new AxisDetails();
            axisDetails.max = 255;
            axisDetails.min = 0;
            device.Axis[JoystickAxis.AxisV] = axisDetails;

            //POV
            axisDetails = new AxisDetails();
            axisDetails.isHat = true;
            device.Axis[JoystickAxis.AxisPovX] = axisDetails;
            axisDetails = new AxisDetails();
            axisDetails.isHat = true;
            device.Axis[JoystickAxis.AxisPovY] = axisDetails;

            ((HIDDevice)hidDevice).InputReportByteLength = 15;
            ((HIDDevice)hidDevice).OutputReportByteLength = 12;

           
            return device;
            //return (IDevice<AxisDetails, ButtonDetails, XInputExtension>)joystick;
        }
        #endregion


        /// <summary>
        ///  Normalize raw axis value to 0-1 range.
        /// </summary>
        /// <param name="pos"></param>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <param name="dreadZone"></param>
        /// <returns></returns>
        public float NormalizeTrigger(float pos, int min, int max, float dreadZone = 0.001f)
        {
            float value =1- pos / (max - min);
            if (value < dreadZone && value > -dreadZone)
                return 0;

            return value;

        }

        private float NormalizeAxis(float pos, int min, int max, float dreadZone = 0.001f)
        {
            //UnityEngine.Debug.Log(Min[axis]+" Max:"+Max[axis]);

            float offset = (2 * (pos - min)) / (max - min) - 1;
            if (offset > 1)
                return 1;
            else if (offset < -1)
                return -1;
            else if (offset < dreadZone && offset > -dreadZone)
                return 0;
            else
                return offset;
        }


      




  


      

        internal void SetLed(XInputDevice device, byte mode)
        {
            //0103xx

            _hidInterface.Write(new byte[]{0x1, 0x3, mode},device);
            //_hidInterface.Write(new byte[] { 0x00, 0x01, 0x0f, 0xc0, 0x00, leftMotor, rightMotor, 0x00, 0x00, 0x00, 0x00, 0x00 }, device, onSetMotor);

        }

        internal void SetMotor(XInputDevice device, byte leftMotor, byte rightMotor)
        {


            _hidInterface.Write(new byte[] { 0x00, 0x01, 0x0f, 0xc0, 0x00, leftMotor, rightMotor, 0x00, 0x00, 0x00, 0x00, 0x00 }, device,onSetMotor);
  
        }

        internal void onSetMotor(bool suc)
        {
            UnityEngine.Debug.Log("Motor was "+(suc? "not set." :"set."));
        }

     


        #region ButtonDetails
        public sealed class ButtonDetails : IButtonDetails
        {

            #region Fields

            float _value;
            uint _uid;
            JoystickButtonState _buttonState;

            #region IDeviceDetails implementation


            public uint uid
            {
                get
                {
                    return _uid;
                }
                set
                {
                    _uid = value;
                }
            }




            public JoystickButtonState buttonState
            {
                get { return _buttonState; }
            }



            public float value
            {
                get
                {
                    return _value;
                    //return (_buttonState==JoystickButtonState.Hold || _buttonState==JoystickButtonState.Down);
                }
                set
                {

                    _value = value;
                    //if pressed==TRUE
                    //TODO check the code with triggers
                    if (value > 0)
                    {
                        if (_buttonState == JoystickButtonState.None
                            || _buttonState == JoystickButtonState.Up)
                        {

                            _buttonState = JoystickButtonState.Down;



                        }
                        else
                        {
                            //if (buttonState == JoystickButtonState.Down)
                            _buttonState = JoystickButtonState.Hold;

                        }


                    }
                    else
                    { //
                        if (_buttonState == JoystickButtonState.Down
                            || _buttonState == JoystickButtonState.Hold)
                        {
                            _buttonState = JoystickButtonState.Up;
                        }
                        else
                        {//if(buttonState==JoystickButtonState.Up){
                            _buttonState = JoystickButtonState.None;
                        }

                    }
                }
            }
            #endregion
            #endregion

            #region Constructor
            public ButtonDetails(uint uid = 0) { this.uid = uid; }
            #endregion






        }

        #endregion

        #region AxisDetails
        public sealed class AxisDetails : IAxisDetails
        {

            #region Fields
            float _value;
            int _uid;
            int _min;
            int _max;
            JoystickButtonState _buttonState;
            bool _isNullable;
            bool _isHat;
            bool _isTrigger;


            #region IAxisDetails implementation



            public bool isTrigger
            {
                get
                {
                    return _isTrigger;
                }
                set
                {
                    _isTrigger = value;
                }
            }



            public int min
            {
                get
                {
                    return _min;
                }
                set
                {
                    _min = value;
                }
            }


            public int max
            {
                get
                {
                    return _max;
                }
                set
                {
                    _max = value;
                }
            }


            public bool isNullable
            {
                get
                {
                    return _isNullable;
                }
                set
                {
                    _isNullable = value;
                }
            }


            public bool isHat
            {
                get
                {
                    return _isHat;
                }
                set
                {
                    _isHat = value;
                }
            }


            #endregion


            #region IDeviceDetails implementation


            public uint uid
            {
                get
                {
                    throw new NotImplementedException();
                }
                set
                {
                    throw new NotImplementedException();
                }
            }


            #endregion

            public JoystickButtonState buttonState
            {
                get { return _buttonState; }
            }
            public float value
            {
                get { return _value; }
                set
                {

                    if (value == 0)
                    {
                        if (_buttonState == JoystickButtonState.Down
                            || _buttonState == JoystickButtonState.Hold)
                        {

                            //axis float value isn't yet update so it have value before getting 0
                            if (_value > 0)//0 come after positive values
                                _buttonState = JoystickButtonState.PosToUp;
                            else
                                _buttonState = JoystickButtonState.NegToUp;

                        }
                        else
                        {//if(buttonState==JoystickButtonState.Up){
                            _buttonState = JoystickButtonState.None;
                        }


                    }
                    else
                    {
                        if (_buttonState == JoystickButtonState.None
                            || _buttonState == JoystickButtonState.Up)
                        {

                            _buttonState = JoystickButtonState.Down;

                        }
                        else
                        {
                            _buttonState = JoystickButtonState.Hold;
                        }


                    }

                    _value = value;



                }//set
            }

            #endregion

        }

        #endregion



        sealed class XInputExtension : IDeviceExtension
        {

        }




    }
}

