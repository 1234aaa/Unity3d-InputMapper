//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.17929
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System.Runtime.InteropServices;


#if UNITY_STANDALONE_OSX || UNITY_EDITOR_OSX
using System;
using ws.winx.devices;
//using UnityEngine;


namespace ws.winx.platform.osx
{


	using CFAllocatorRef = System.IntPtr;
	using CFDictionaryRef = System.IntPtr;
	using CFArrayRef = System.IntPtr;
	using CFIndex = System.IntPtr;
	using CFRunLoop = System.IntPtr;
	using CFString = System.IntPtr;
	using CFStringRef = System.IntPtr; // Here used interchangeably with the CFString
	using CFTypeRef = System.IntPtr;
	using IOHIDDeviceRef = System.IntPtr;
	using IOHIDElementRef = System.IntPtr;
	using IOHIDManagerRef = System.IntPtr;
	using IOHIDValueRef = System.IntPtr;
	using IOOptionBits = System.IntPtr;
	using IOReturn =Native.IOReturn;// System.IntPtr;

	using IOHIDElementType=Native.IOHIDElementType;





	sealed class OSXDriver:IDriver
		{

#region Fields


		IHIDInterface _hidInterface;
		
	
		
        #endregion




#region Constructor
        public OSXDriver()
				{
				
					

				}
        #endregion


#region Private Members




        /// <summary>
		/// Devices the value received.
		/// </summary>
		/// <param name="context">Context.</param>
		/// <param name="res">Res.</param>
		/// <param name="sender">Sender.</param>
		/// <param name="valRef">Value reference.</param>
		internal void DeviceValueReceived(IntPtr context, IOReturn res, IntPtr sender, IOHIDValueRef valRef)
		{
			IOHIDElementRef element = Native.IOHIDValueGetElement(valRef);
			uint uid=Native.IOHIDElementGetCookie(element);
			long value;
			Native.IOHIDElementType  type = Native.IOHIDElementGetType(element);
			IDevice device;
			try{
			GCHandle gch = GCHandle.FromIntPtr(context);
			 device=(IDevice) gch.Target;

			}
			catch(Exception e){
				UnityEngine.Debug.LogException(e);
				return;
		}


			if (!device.isReady)
								return;


//			if (Native.IOHIDValueGetLength(valRef) > 4) {
//				// Workaround for a strange crash that occurs with PS3 controller; was getting lengths of 39 (!)
//				return;
//			}

			value=Native.IOHIDValueGetIntegerValue(valRef);

			//AXIS
			if(type==Native.IOHIDElementType.kIOHIDElementTypeInput_Misc
			   || type==Native.IOHIDElementType.kIOHIDElementTypeInput_Axis)
			{
				int numAxes=device.Axis.Count;
				AxisDetails axisDetails;






				for (int axisIndex = 0; axisIndex < numAxes; axisIndex++) {

					axisDetails=device.Axis[axisIndex] as AxisDetails;

					if (axisDetails!=null && axisDetails.uid== uid) {
						//check hatch
						//Check if POV element.
						if((Native.IOHIDElementGetUsage(element) & (uint)Native.HIDUsageGD.Hatswitch)!=0)
						{
									//Workaround for POV hat switches that do not have null states.
									if(!axisDetails.isNullable)
									{
										value = value < axisDetails.min ? axisDetails.max - axisDetails.min + 1 : value - 1;
									}

							//todo change them to float
							int outX;
							int outY;

							hatValueToXY(value,(axisDetails.max - axisDetails.min)+1,out outX,out outY);

							device.Axis[JoystickAxis.AxisPovX].value=outX;
							device.Axis[JoystickAxis.AxisPovY].value=outY;

									
						
						}else{
							//Sanity check.
							if(value < axisDetails.min)
							{
								value = axisDetails.min;
							}
							if(value > axisDetails.max)
							{
								value = axisDetails.max;
							}

							//Calculate the -1 to 1 float from the min and max possible values.
							axisDetails.value=(value - axisDetails.min) / (float)(axisDetails.max - axisDetails.min) * 2.0f - 1.0f;

						}



						return;
					}

				}//end for

			//BUTTONS
			}else if(type==Native.IOHIDElementType.kIOHIDElementTypeInput_Button){

				int numButtons=device.Buttons.Count;

				for (int buttonIndex = 0; buttonIndex < numButtons; buttonIndex++) {
					if ( device.Buttons[buttonIndex].uid== uid) {

						device.Buttons[buttonIndex].value=value;


						
						return;
					}
				}
			}

		}



//					   0                 
//					   |
//				3______|______1
//					   |
//					   |
//					   2



		//				  7    0     1            
		//				   \   |   /
		//				6 _____|______2
		// 					  /|\
		//					/  |  \
		//				   5   4    3


		/// <summary>
		/// Hats the value to X.
		/// </summary>
		/// <param name="value">Value.</param>
		/// <param name="range">Range.</param>
		/// <param name="outX">Out x.</param>
		/// <param name="outY">Out y.</param>
		 void hatValueToXY(long value, int range,out int outX,out int outY) {

				outX = outY = 0;
				int rangeHalf=range>>1;
				int rangeQuat=range>>2;
				
				if (value > 0 && value < rangeHalf) {
					outX = 1;
					
				} else if (value > rangeHalf) {
					outX = -1;					
				} 
				
				if (value > rangeQuat * 3 || value < rangeQuat) {
					outY = 1;
					
				} else if (value > rangeQuat && value < rangeQuat * 3) {
					outY = -1;					
				} 

		}




        #endregion








#region IJoystickDriver implementation
		/// <summary>
		/// Update the specified joystick.
		/// </summary>
		/// <param name="joystick">Joystick.</param>
         public void Update(IDevice joystick)
	
		{
            throw new Exception("OSX Default driver is meant to auto update on callback");
		}

		/// <summary>
		/// Resolves the device.
		/// </summary>
		/// <returns>returns JoystickDevice if driver is for this device or null</returns>
		/// <param name="info">Info.</param>
		/// <param name="hidDevice">Hid device.</param>
		public IDevice ResolveDevice (IHIDDevice hidDevice)
		
		{

			_hidInterface=hidDevice.hidInterface;


			return CreateDevice(hidDevice);
		}




	/// <summary>
	/// Creates the device.
	/// </summary>
	/// <returns>The device.</returns>
	/// <param name="info">Info.</param>
		public IDevice CreateDevice(IHIDDevice info){

			IntPtr device=info.deviceHandle;
			//JoystickDevice<IAxisDetails,IButtonDetails,IDeviceExtension> joystick;
			JoystickDevice joystick;
			int axisIndex=0;
			int buttonIndex=0;

			Native.CFArray elements=new Native.CFArray();
			IOHIDElementRef element;
			IOHIDElementType type;

			//copy all matched 
			elements.typeRef=Native.IOHIDDeviceCopyMatchingElements(device, IntPtr.Zero,(int)Native.IOHIDOptionsType.kIOHIDOptionsTypeNone );
			
			int numButtons=0;
			int numAxis=0;

			int numElements=elements.Length;
			int HIDElementType=Native.IOHIDElementGetTypeID();
			int numPov = 0;

			
							for (int elementIndex = 0; elementIndex < numElements; elementIndex++){
									element =  elements[elementIndex].typeRef;
				if(element!=IntPtr.Zero && Native.CFGetTypeID(element) == HIDElementType){
								
								type = Native.IOHIDElementGetType(element);
			
			
								// All of the axis elements I've ever detected have been kIOHIDElementTypeInput_Misc. kIOHIDElementTypeInput_Axis is only included for good faith...
								if (type == IOHIDElementType.kIOHIDElementTypeInput_Misc ||
								    type == IOHIDElementType.kIOHIDElementTypeInput_Axis) {
									numAxis++;
						            
									if(Native.IOHIDElementGetUsage(element)==(uint)Native.HIDUsageGD.Hatswitch){
							numPov++;
						}

						          
							
								} else if (type == IOHIDElementType.kIOHIDElementTypeInput_Button) {
									numButtons++;
								}
				}
			
						}


			if (numPov > 0)
								numAxis = Math.Max (8, numAxis);

			joystick=new JoystickDevice(info.index,info.PID,info.PID,numAxis,numButtons,this);
			joystick.numPOV = numPov;

			
			AxisDetails axisDetails;


			for (int elementIndex = 0; elementIndex < numElements; elementIndex++){
				element = elements[elementIndex].typeRef;

				if(element!=IntPtr.Zero && Native.CFGetTypeID(element) == HIDElementType){
				type = Native.IOHIDElementGetType(element);
				
				

				
				// All of the axis elements I've ever detected have been kIOHIDElementTypeInput_Misc. kIOHIDElementTypeInput_Axis is only included for good faith...
				if (type == IOHIDElementType.kIOHIDElementTypeInput_Misc ||
				    type == IOHIDElementType.kIOHIDElementTypeInput_Axis) {
					
					

					axisDetails=new AxisDetails();

					axisDetails.uid=Native.IOHIDElementGetCookie(element);
					axisDetails.min=(int)Native.IOHIDElementGetLogicalMin(element);
					axisDetails.max=(int)Native.IOHIDElementGetLogicalMax(element);
					axisDetails.isNullable=Native.IOHIDElementHasNullState(element);
					
					
					
					if(Native.IOHIDElementGetUsage(element)==(uint)Native.HIDUsageGD.Hatswitch){

						
						axisDetails.isHat=true;
						

							joystick.Axis[JoystickAxis.AxisPovY]=axisDetails;
						
							
							axisDetails=new AxisDetails();
							
							axisDetails.uid=Native.IOHIDElementGetCookie(element);
							axisDetails.min=(int)Native.IOHIDElementGetLogicalMin(element);
							axisDetails.max=(int)Native.IOHIDElementGetLogicalMax(element);
							axisDetails.isNullable=Native.IOHIDElementHasNullState(element);
							axisDetails.isHat=true;
							joystick.Axis[JoystickAxis.AxisPovX]=axisDetails;
						
						
						
					}else{
						
						
						
						joystick.Axis[(JoystickAxis)axisIndex]=axisDetails;
						
					}
					axisIndex++;
					
					
				} else if (type == IOHIDElementType.kIOHIDElementTypeInput_Button) {
						//
						joystick.Buttons[buttonIndex]=new ButtonDetails(Native.IOHIDElementGetCookie(element));  
					buttonIndex++;
					
				}
				}
				
			}









						joystick.Extension=new OSXDefaultExtension();
//			JoystickDevice<AxisDetails,ButtonDetails,OSXDefaultExtension> joystick;
//			joystick=new JoystickDevice<AxisDetails,ButtonDetails,OSXDefaultExtension>(id,axes,buttons);
//			joystick.Extension=new OSXDefaultExtension();







             return joystick;
			//return (IDevice<IAxisDetails,IButtonDetails,IDeviceExtension>)joystick;
			//return joystick as IDevice<AxisDetails,ButtonDetails,OSXDefaultExtension>;
		}
		


#region ButtonDetails
		public sealed class ButtonDetails:IButtonDetails{
			
#region Fields
			
			float _value;
			uint _uid;
			JoystickButtonState _buttonState;

#region IDeviceDetails implementation


			public uint uid {
				get {
					return _uid;
				}
				set {
					_uid=value;
				}
			}




			public JoystickButtonState buttonState{
				get{return _buttonState; }
			}



			public float value{
				get{
					return _value;
					//return (_buttonState==JoystickButtonState.Hold || _buttonState==JoystickButtonState.Down);
				}
				set{

					_value=value;
					//if pressed==TRUE
					//TODO check the code with triggers
					if (value>0) {
						if (_buttonState == JoystickButtonState.None 
						    || _buttonState == JoystickButtonState.Up) {
							
								_buttonState = JoystickButtonState.Down;
							
							
							
						} else {
							//if (buttonState == JoystickButtonState.Down)
							 _buttonState = JoystickButtonState.Hold;
							
						}
						
						
					} else { //
						if (_buttonState == JoystickButtonState.Down
						    || _buttonState == JoystickButtonState.Hold) {
							_buttonState = JoystickButtonState.Up;
						} else {//if(buttonState==JoystickButtonState.Up){
							_buttonState = JoystickButtonState.None; 
						}
						
					}
				}
			}
            #endregion
            #endregion

#region Constructor
			public ButtonDetails(uint uid=0){this.uid=uid; }
            #endregion
			
			
			
			
			
			
		}
		
        #endregion
		
#region AxisDetails
		public sealed class AxisDetails:IAxisDetails{

#region Fields
			float _value;
			uint _uid;
			int _min;
			int _max;
			JoystickButtonState _buttonState;
			bool _isNullable;
			bool _isHat;

#region IAxisDetails implementation



			public bool isTrigger {
				get {
					throw new NotImplementedException ();
				}
				set {
					throw new NotImplementedException ();
				}
			}




			public int min {
				get {
					return _min;
				}
				set {
					_min=value;
				}
			}


			public int max {
				get {
					return _max;
				}
				set {
					_max=value;
				}
			}


			public bool isNullable {
				get {
					return _isNullable;
				}
				set {
					_isNullable=value;
				}
			}


			public bool isHat {
				get {
					return _isHat;
				}
				set {
					_isHat=value;
				}
			}


            #endregion


#region IDeviceDetails implementation


			public uint uid {
				get {
					return _uid;
				}
				 set {
					_uid=value;
				}
			}


            #endregion

			public JoystickButtonState buttonState{
				get{return _buttonState; }
			}
			public float value{
				get{ return _value;}
				set{ 
					
					if (value == 0) {
						if (_buttonState == JoystickButtonState.Down
						    || _buttonState == JoystickButtonState.Hold){
							
							//axis float value isn't yet update so it have value before getting 0
							if (_value > 0)//0 come after positive values
								_buttonState = JoystickButtonState.PosToUp;
							else
								_buttonState = JoystickButtonState.NegToUp;
							
						}else {//if(buttonState==JoystickButtonState.Up){
							_buttonState = JoystickButtonState.None; 
						}
						
						
					} else { 
						if (_buttonState == JoystickButtonState.None 
						    || _buttonState == JoystickButtonState.Up) {
							
							_buttonState = JoystickButtonState.Down;
							
						} else {
							_buttonState = JoystickButtonState.Hold;
						}
						
						
					}
					
					_value=value;
					
					
					
				}//set
			}

            #endregion
			
		}
		
        #endregion







		public sealed class OSXDefaultExtension:IDeviceExtension{
		}




		}
}

        #endregion
#endif