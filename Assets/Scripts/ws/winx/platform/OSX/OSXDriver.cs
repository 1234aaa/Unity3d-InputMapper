//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.17929
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System.Runtime.InteropServices;


#if UNITY_STANDALONE_OSX || UNITY_EDITOR_OSX
using System;
using ws.winx.devices;
//using UnityEngine;


namespace ws.winx.platform.osx
{



	using CFString = System.IntPtr;

	using CFTypeRef = System.IntPtr;
	using IOHIDDeviceRef = System.IntPtr;
	using IOHIDElementRef = System.IntPtr;

	using IOHIDValueRef = System.IntPtr;
	using IOOptionBits = System.IntPtr;
	using IOReturn =Native.IOReturn;// System.IntPtr;

	using IOHIDElementType=Native.IOHIDElementType;





	sealed class OSXDriver:IDriver
		{

#region Fields

		IHIDInterface _hidInterface;

		
	
		
        #endregion




#region Constructor
        public OSXDriver()
				{
				
					

				}
        #endregion


#region Private Members




     /// <summary>
     /// Devices the value received.
     /// </summary>
     /// <param name="device">Device.</param>
     /// <param name="type">Type.</param>
     /// <param name="uid">Uid.</param>
     /// <param name="value">Value.</param>
		internal void DeviceValueReceived(IDevice device,Native.IOHIDElementType type,uint uid,long value)
		{
			//UnityEngine.Debug.Log ("OSXDriver>>DeviceValueReceived");
		

			//AXIS
			if(type==Native.IOHIDElementType.kIOHIDElementTypeInput_Misc
			   || type==Native.IOHIDElementType.kIOHIDElementTypeInput_Axis)
			{
				int numAxes=device.Axis.Count;
				AxisDetails axisDetails;


				for (int axisIndex = 0; axisIndex < numAxes; axisIndex++) {

					axisDetails=device.Axis[axisIndex] as AxisDetails;

					if (axisDetails!=null && axisDetails.uid== uid) {



						//check hatch
						//Check if POV element.
						if(axisDetails.isHat)
						{
									//Workaround for POV hat switches that do not have null states.
									if(!axisDetails.isNullable)
									{
										value = value < axisDetails.min ? axisDetails.max - axisDetails.min + 1 : value - 1;
									}

							//Todo change them to float
							float outX=0f;
							float outY=0f;

							if(value<15)
							hatValueToXY(value,(axisDetails.max - axisDetails.min)+1,out outX,out outY);

							device.Axis[JoystickAxis.AxisPovX].value=outX;
							device.Axis[JoystickAxis.AxisPovY].value=outY;

							//UnityEngine.Debug.Log("POVX:"+device.Axis[JoystickAxis.AxisPovX].value+" POVY:"+device.Axis[JoystickAxis.AxisPovY].value);	
						
						}else{
							//Sanity check.
							if(value < axisDetails.min)
							{
								value = axisDetails.min;
							}
							if(value > axisDetails.max)
							{
								value = axisDetails.max;
							}

							//Calculate the -1 to 1 float from the min and max possible values.
							axisDetails.value=(value - axisDetails.min) / (float)(axisDetails.max - axisDetails.min) * 2.0f - 1.0f;

							//UnityEngine.Debug.Log("AxisValue:"+axisDetails.value);

						}



						return;
					}

				}//end for

			//BUTTONS
			}else if(type==Native.IOHIDElementType.kIOHIDElementTypeInput_Button){

				int numButtons=device.Buttons.Count;

				for (int buttonIndex = 0; buttonIndex < numButtons; buttonIndex++) {
					if ( device.Buttons[buttonIndex].uid== uid) {

						device.Buttons[buttonIndex].value=value;

						UnityEngine.Debug.Log("Button "+buttonIndex+" value:"+value+" State:"+device.Buttons[buttonIndex].buttonState);
						
						return;
					}
				}
			}

		}

		 

//					   0                 
//					   |
//				3______|______1
//					   |
//					   |
//					   2



		//				  7    0     1            
		//				   \   |   /
		//				6 _____|______2
		// 					  /|\
		//					/  |  \
		//				   5   4    3


		/// <summary>
		/// Hats the value to X.
		/// </summary>
		/// <param name="value">Value.</param>
		/// <param name="range">Range.</param>
		/// <param name="outX">Out x.</param>
		/// <param name="outY">Out y.</param>
		 void hatValueToXY(long value, int range,out float outX,out float outY) {

				outX = outY = 0f;
				int rangeHalf=range>>1;
				int rangeQuat=range>>2;
				
				if (value > 0 && value < rangeHalf) {
					outX = 1f;
					
				} else if (value > rangeHalf) {
					outX = -1f;					
				} 
				
				if (value > rangeQuat * 3 || value < rangeQuat) {
					outY = 1f;
					
				} else if (value > rangeQuat && value < rangeQuat * 3) {
					outY = -1f;					
				} 

		}




        #endregion








#region IJoystickDriver implementation
		/// <summary>
		/// Update the specified device.
		/// </summary>
		/// <param name="device">Joystick.</param>
         public void Update(IDevice device)	
		{

			HIDReport report = _hidInterface.Read (device.PID);

			if (report.Status == HIDReport.ReadStatus.Success) {


				DeviceValueReceived(device,(Native.IOHIDElementType)BitConverter.ToUInt32(report.Data,0),BitConverter.ToUInt32(report.Data,4),BitConverter.ToInt64(report.Data,8));
			}


		}

		/// <summary>
		/// Resolves the device.
		/// </summary>
		/// <returns>returns JoystickDevice if driver is for this device or null</returns>
		/// <param name="info">Info.</param>
		/// <param name="hidDevice">Hid device.</param>
		public IDevice ResolveDevice (IHIDDevice hidDevice)
		
		{
	
			this._hidInterface = hidDevice.hidInterface;

			IntPtr device=hidDevice.deviceHandle;

			JoystickDevice joystick;
			int axisIndex=0;
			int buttonIndex=0;

			Native.CFArray elements=new Native.CFArray();
			IOHIDElementRef element;
			IOHIDElementType type;

			//copy all matched 
			elements.typeRef=Native.IOHIDDeviceCopyMatchingElements(device, IntPtr.Zero,(int)Native.IOHIDOptionsType.kIOHIDOptionsTypeNone );
			
			int numButtons=0;
			int numAxis=0;

			int numElements=elements.Length;
			int HIDElementType=Native.IOHIDElementGetTypeID();
			int numPov = 0;

			
							for (int elementIndex = 0; elementIndex < numElements; elementIndex++){
									element =  elements[elementIndex].typeRef;
				if(element!=IntPtr.Zero && Native.CFGetTypeID(element) == HIDElementType){
								
								type = Native.IOHIDElementGetType(element);
			
			
								// All of the axis elements I've ever detected have been kIOHIDElementTypeInput_Misc. kIOHIDElementTypeInput_Axis is only included for good faith...
								if (type == IOHIDElementType.kIOHIDElementTypeInput_Misc ||
								    type == IOHIDElementType.kIOHIDElementTypeInput_Axis) {
									numAxis++;
						            
									if(Native.IOHIDElementGetUsage(element)==(uint)Native.HIDUsageGD.Hatswitch){
							numPov++;
						}

						          
							
								} else if (type == IOHIDElementType.kIOHIDElementTypeInput_Button) {
									numButtons++;
								}
				}
			
						}


			if (numPov > 0)
								numAxis = Math.Max (8, numAxis);

			joystick=new JoystickDevice(hidDevice.index,hidDevice.PID,hidDevice.VID,numAxis,numButtons,this);
			joystick.numPOV = numPov;

			
			AxisDetails axisDetails;


			for (int elementIndex = 0; elementIndex < numElements; elementIndex++){
				element = elements[elementIndex].typeRef;

				if(element!=IntPtr.Zero && Native.CFGetTypeID(element) == HIDElementType){
				type = Native.IOHIDElementGetType(element);
				
				

				
				// All of the axis elements I've ever detected have been kIOHIDElementTypeInput_Misc. kIOHIDElementTypeInput_Axis is only included for good faith...
				if (type == IOHIDElementType.kIOHIDElementTypeInput_Misc ||
				    type == IOHIDElementType.kIOHIDElementTypeInput_Axis) {
					
					

					axisDetails=new AxisDetails();

					axisDetails.uid=Native.IOHIDElementGetCookie(element);
					axisDetails.min=(int)Native.IOHIDElementGetLogicalMin(element);
					axisDetails.max=(int)Native.IOHIDElementGetLogicalMax(element);
					axisDetails.isNullable=Native.IOHIDElementHasNullState(element);
					
					
					
					if(Native.IOHIDElementGetUsage(element)==(uint)Native.HIDUsageGD.Hatswitch){

						
						axisDetails.isHat=true;
						

							joystick.Axis[JoystickAxis.AxisPovY]=axisDetails;
						
							
							axisDetails=new AxisDetails();
							
							axisDetails.uid=Native.IOHIDElementGetCookie(element);
							axisDetails.min=(int)Native.IOHIDElementGetLogicalMin(element);
							axisDetails.max=(int)Native.IOHIDElementGetLogicalMax(element);
							axisDetails.isNullable=Native.IOHIDElementHasNullState(element);
							axisDetails.isHat=true;
							joystick.Axis[JoystickAxis.AxisPovX]=axisDetails;
						
						
						
					}else{
						
						
						
						joystick.Axis[(JoystickAxis)axisIndex]=axisDetails;
						
					}
					axisIndex++;
					
					
				} else if (type == IOHIDElementType.kIOHIDElementTypeInput_Button) {
						//
						joystick.Buttons[buttonIndex]=new ButtonDetails(Native.IOHIDElementGetCookie(element));  
					buttonIndex++;
					
				}
				}
				
			}







			//joystick.isReady = false;

						joystick.Extension=new OSXDefaultExtension();








             return joystick;

		}
		


#region ButtonDetails
		public sealed class ButtonDetails:IButtonDetails{
			
#region Fields
			
			float _value;
			uint _uid;
			JoystickButtonState _buttonState;

#region IDeviceDetails implementation


			public uint uid {
				get {
					return _uid;
				}
				set {
					_uid=value;
				}
			}




			public JoystickButtonState buttonState{
				get{return _buttonState; }
			}



			public float value{
				get{
					return _value;
					//return (_buttonState==JoystickButtonState.Hold || _buttonState==JoystickButtonState.Down);
				}
				set{

					_value = value;
					
					//  UnityEngine.Debug.Log("Value:" + _value);
					
					//if pressed==TRUE
					//TODO check the code with triggers
					if (value > 0)
					{
						if (_buttonState == JoystickButtonState.None
						    || _buttonState == JoystickButtonState.Up)
						{
							
							_buttonState = JoystickButtonState.Down;
							
							
							
						}
						else
						{
							//if (buttonState == JoystickButtonState.Down)
							_buttonState = JoystickButtonState.Hold;
							
						}
						
						
					}
					else
					{ //
						if (_buttonState == JoystickButtonState.Down
						    || _buttonState == JoystickButtonState.Hold)
						{
							_buttonState = JoystickButtonState.Up;
						}
						else
						{//if(buttonState==JoystickButtonState.Up){
							_buttonState = JoystickButtonState.None;
						}
						
					}
				}//set
			}
			#endregion
			#endregion
			
			#region Constructor
			public ButtonDetails(uint uid=0){this.uid=uid; }
			#endregion
			
			
			
			
			
			
		}
		
		#endregion
		
		#region AxisDetails
		public sealed class AxisDetails:IAxisDetails{
			
			#region Fields
			float _value;
			uint _uid;
			int _min;
			int _max;
			JoystickButtonState _buttonState;
			bool _isNullable;
			bool _isHat;
			
			#region IAxisDetails implementation
				
				
				
				public bool isTrigger {
					get {
						throw new NotImplementedException ();
					}
					set {
						throw new NotImplementedException ();
					}
				}




			public int min {
				get {
					return _min;
				}
				set {
					_min=value;
				}
			}


			public int max {
				get {
					return _max;
				}
				set {
					_max=value;
				}
			}


			public bool isNullable {
				get {
					return _isNullable;
				}
				set {
					_isNullable=value;
				}
			}


			public bool isHat {
				get {
					return _isHat;
				}
				set {
					_isHat=value;
				}
			}


            #endregion


#region IDeviceDetails implementation


			public uint uid {
				get {
					return _uid;
				}
				 set {
					_uid=value;
				}
			}


            #endregion

			public JoystickButtonState buttonState{
				get{return _buttonState; }
			}
			public float value{
				get{ return _value;}
				set{ 
					
					
					if (value == 0)
					{
						if (_buttonState == JoystickButtonState.Down
						    || _buttonState == JoystickButtonState.Hold)
						{
							
							//axis float value isn't yet update so it have value before getting 0
							if (_value > 0)//0 come after positive values
								_buttonState = JoystickButtonState.PosToUp;
							else
								_buttonState = JoystickButtonState.NegToUp;
							
						}
						else
						{//if(buttonState==JoystickButtonState.Up){
							_buttonState = JoystickButtonState.None;
						}
						
						
					}
					else
						//!!! value can jump from >0 to <0 without go to 0(might go to "Down" directly for triggers axis)
					{
						if (_value > 0 && value < 0)
						{
							_buttonState = JoystickButtonState.PosToUp;
						}
						else if (_value < 0 && value > 0)
						{
							_buttonState = JoystickButtonState.NegToUp;
						}
						else if (_buttonState == JoystickButtonState.None
						         || _buttonState == JoystickButtonState.PosToUp || _buttonState == JoystickButtonState.NegToUp)
						{
							
							_buttonState = JoystickButtonState.Down;
							
						}
						else
						{
							_buttonState = JoystickButtonState.Hold;
						}
						
						
					}
					
					
					
					
					_value = value;
					
					
					
				}//set
			}
			
			#endregion
			
		}
		
		#endregion
		
		
		
		
		
		
		
		public sealed class OSXDefaultExtension:IDeviceExtension{
		}
		
		
		
		
	}
}

#endregion
#endif