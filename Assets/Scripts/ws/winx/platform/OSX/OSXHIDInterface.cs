//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.17929
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#if UNITY_STANDALONE_OSX || UNITY_EDITOR_OSX
using System;
using System.Collections.Generic;
using ws.winx.devices;
using System.Runtime.InteropServices;
using System.Linq;


namespace ws.winx.platform.osx
{

   

    using UnityEngine; 
	using CFAllocatorRef=System.IntPtr;
	using CFDictionaryRef=System.IntPtr;
	using CFStringRef=System.IntPtr;
	using CFNumberRef=System.IntPtr;
	using CFArrayCallBacks=System.IntPtr;
	using CFArrayRef = System.IntPtr;
	using CFTypeRef = System.IntPtr;
	using IOHIDDeviceRef = System.IntPtr;
	using IOHIDElementRef = System.IntPtr;
	using IOHIDManagerRef = System.IntPtr;
	using IOHIDValueRef = System.IntPtr;
	using IOOptionBits = System.IntPtr;
	using IOReturn = System.IntPtr;
	using IOHIDElementCookie = System.UInt32;
	using CFTypeID=System.UInt64;
	using CFIndex =System.Int64;



    sealed class OSXHIDInterface : IHIDInterface
    {

#region Fields

        readonly IOHIDManagerRef hidmanager;


        readonly IntPtr RunLoop = Native.CFRunLoopGetMain();
		readonly IntPtr InputLoopMode = Native.RunLoopModeDefault;
        readonly Native.CFArray DeviceTypes;

        Native.IOHIDDeviceCallback HandleDeviceAdded;
        Native.IOHIDDeviceCallback HandleDeviceRemoved;
        Native.IOHIDValueCallback HandleDeviceValueReceived;

        bool disposed;


        private List<IDriver> __drivers = new List<IDriver>();



        private IDriver __defaultJoystickDriver;

        JoystickDevicesCollection _joysticks;



        #endregion

#region IHIDInterface implementation



		public void Read (IDevice device, HIDDevice.ReadCallback callback)
		{
			throw new NotImplementedException ();
		}

		public void Read (IDevice device, HIDDevice.ReadCallback callback, int timeout)
		{
			throw new NotImplementedException ();
		}

		public void Write (object data, IDevice device, HIDDevice.WriteCallback callback, int timeout)
		{
			throw new NotImplementedException ();
		}

		public void Write (object data, IDevice device, HIDDevice.WriteCallback callback)
		{
			throw new NotImplementedException ();
		}

		public void Write (object data, IDevice device)
		{
			throw new NotImplementedException ();
		}

		public Dictionary<IDevice, HIDDevice> Generics {
			get {
				throw new NotImplementedException ();
			}
		}


        public IDriver defaultDriver
        {
            get { if (__defaultJoystickDriver == null) { __defaultJoystickDriver = new OSXDriver(); } return __defaultJoystickDriver; }
            set { __defaultJoystickDriver = value; }

        }




        public IDeviceCollection Devices
        {

            get { return _joysticks; }

        }





        public void Update()
        {
        }

        #endregion



#region Contsructor

        public OSXHIDInterface(List<IDriver> drivers)
        {
            __drivers = drivers;


            HandleDeviceAdded = DeviceAdded;
            HandleDeviceRemoved = DeviceRemoved;
          
            CFDictionaryRef[] dictionaries;
           


		

            
            dictionaries = new CFDictionaryRef[3];

            //create 3 search patterns by Joystick,GamePad and MulitAxisController

			// base.typeRef = CFLibrary.CFDictionaryCreate(IntPtr.Zero,keyz,values,keys.Length,ref kcall,ref vcall); 

			IntPtr ptr;


			dictionaries[0] = CreateDeviceMatchingDictionary((uint)Native.HIDPage.GenericDesktop,(uint)Native.HIDUsageGD.Joystick);
			
			
			
			dictionaries[1] = CreateDeviceMatchingDictionary((uint)Native.HIDPage.GenericDesktop,(uint)Native.HIDUsageGD.GamePad);

			dictionaries[2] = CreateDeviceMatchingDictionary((uint)Native.HIDPage.GenericDesktop,(uint)Native.HIDUsageGD.MultiAxisController);



			Native.CFDictionary dict;
			dict= new Native.CFDictionary (dictionaries [0]);

			Native.CFType a = dict[Native.IOHIDDeviceUsagePageKey];


			int type=a.GetTypeID ();
			Native.CFNumber value=a as Native.CFNumber;

			int real = (int)value.ToInteger ();

			return;


			
			Native.CFArray array = new Native.CFArray (dictionaries);
			dict = array[2] as Native.CFDictionary;
			 value = dict[Native.IOHIDDeviceUsagePageKey] as Native.CFNumber;

            DeviceTypes.typeRef = Native.CFArrayCreate(IntPtr.Zero, dictionaries, 3, IntPtr.Zero);

            //create Hid manager	
            hidmanager = Native.IOHIDManagerCreate(IntPtr.Zero, IntPtr.Zero);

			if (hidmanager != IntPtr.Zero) {	

				_joysticks = new JoystickDevicesCollection();

				//Register add/remove device handlers
				RegisterHIDCallbacks(hidmanager);
				
			
			}else
				UnityEngine.Debug.LogError("Creating of OSX HIDManager failed");         






        }
        #endregion





#region Private Members

		static CFDictionaryRef /*CFMutableDictionaryRef*/ CreateDeviceMatchingDictionary(uint inUsagePage, uint inUsage)
		{
				IntPtr pageCFNumberRef=(new Native.CFNumber((int)inUsagePage)).typeRef;
				IntPtr usageCFNumberRef=(new Native.CFNumber((int)inUsage)).typeRef;
				CFStringRef[] keys;
				keys = new IntPtr[2];
			keys[0] = Native.CFSTR (Native.IOHIDDeviceUsagePageKey);//new Native.CFString(Native.IOHIDDeviceUsagePageKey);
			keys[1] = Native.CFSTR (Native.IOHIDDeviceUsageKey);//new Native.CFString(Native.IOHIDDeviceUsageKey);

			Native.CFDictionary dict = new Native.CFDictionary (keys, new IntPtr[] { 
				pageCFNumberRef,usageCFNumberRef});
			
			return dict.typeRef;

			
			// create a dictionary to add usage page/usages to
			//NativeMethod
//			CFMutableDictionaryRef result = CFDictionaryCreateMutable(
//				kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
//			Native..CFDictionary result=new ComRegisterFunctionAttribute.
//
//
//			if (result) {
//				if (inUsagePage) {
//					// Add key for device type to refine the matching dictionary.
//
//
//					CFNumberRef pageCFNumberRef = CFNumberCreate(
//						kCFAllocatorDefault, kCFNumberIntType, &inUsagePage);
//					if (pageCFNumberRef) {
//						CFDictionarySetValue(result,
//						                     CFSTR(kIOHIDDeviceUsagePageKey), pageCFNumberRef);
//						CFRelease(pageCFNumberRef);
//						
//						// note: the usage is only valid if the usage page is also defined
//						if (inUsage) {
//							CFNumberRef usageCFNumberRef = CFNumberCreate(
//								kCFAllocatorDefault, kCFNumberIntType, &inUsage);
//							if (usageCFNumberRef) {
//								CFDictionarySetValue(result,
//								                     CFSTR(kIOHIDDeviceUsageKey), usageCFNumberRef);
//								CFRelease(usageCFNumberRef);
//							} else {
//								fprintf(stderr, "%s: CFNumberCreate(usage) failed.", __PRETTY_FUNCTION__);
//							}
//						}
//					} else {
//						fprintf(stderr, "%s: CFNumberCreate(usage page) failed.", __PRETTY_FUNCTION__);
//					}
//				}
//			} else {
//				fprintf(stderr, "%s: CFDictionaryCreateMutable failed.", __PRETTY_FUNCTION__);
//			}
//			return result;
		}   // hu_CreateDeviceMatchingDictionary
//		
//		// Create a matching dictionary
//		CFDictionaryRef matchingCFDictRef =
//			hu_CreateDeviceMatchingDictionary(kHIDPage_GenericDesktop, kHIDUsage_GD_Keyboard);
//		if (matchingCFDictRef) {
//			// set the HID device matching dictionary
//			IOHIDManagerSetDeviceMatching(managerRef, matchingCFDictRef);
//		} else {
//			fprintf(stderr, "%s: hu_CreateDeviceMatchingDictionary failed.", __PRETTY_FUNCTION__);
//		}
//		
//		// create an array of matching dictionaries
//		CFArrayRef matchingCFArrayRef = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
//		if (matchingCFArrayRef) {
//			// create a device matching dictionary for joysticks
//			CFDictionaryRef matchingCFDictRef =
//				hu_CreateDeviceMatchingDictionary(kHIDPage_GenericDesktop, kHIDUsage_GD_Joystick);
//			if (matchingCFDictRef) {
//				// add it to the matching array
//				CFArrayAppendValue(matchingCFArrayRef, matchingCFDictRef);
//				CFRelease(matchingCFDictRef); // and release it
//			} else {
//				fprintf(stderr, "%s: hu_CreateDeviceMatchingDictionary(joystick) failed.", __PRETTY_FUNCTION__);
//			}
//			
//			// create a device matching dictionary for game pads
//			matchingCFDictRef = hu_CreateDeviceMatchingDictionary(kHIDPage_GenericDesktop, kHIDUsage_GD_GamePad);
//			if (matchingCFDictRef) {
//				// add it to the matching array
//				CFArrayAppendValue(matchingCFArrayRef, matchingCFDictRef);
//				CFRelease(matchingCFDictRef); // and release it
//			} else {
//				fprintf(stderr, "%s: hu_CreateDeviceMatchingDictionary(game pad) failed.", __PRETTY_FUNCTION__);
//			}
//		} else {
//			fprintf(stderr, "%s: CFArrayCreateMutable failed.", __PRETTY_FUNCTION__);
//		}
//		
//		-- EITHER --
//			
//			// create a dictionary for the kIOHIDDeviceUsagePairsKey entry
//			matchingCFDictRef = CFDictionaryCreateMutable(
//				kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
//		
//		// add the matching array to it
//		CFDictionarySetValue(matchingCFDictRef, CFSTR(kIOHIDDeviceUsagePairsKey), matchingCFArrayRef);
//		// release the matching array
//		CFRelease(matchingCFArrayRef);
//		
//		// set the HID device matching dictionary
//		IOHIDManagerSetDeviceMatching(managerRef, matchingCFDictRef);
//		
//		// and then release it
//		CFRelease(matchingCFDictRef);
//		
//		-- OR --
//			
//			// set the HID device matching array
//			IOHIDManagerSetDeviceMatchingMultiple(managerRef, matchingCFArrayRef);
//		
//		// and then release it
//		CFRelease(matchingCFArrayRef);
		
		// Registers callbacks for device addition and removal. These callbacks
		// are called when we run the loop in CheckDevicesMode
		void RegisterHIDCallbacks(IOHIDManagerRef hidmanager)
		{
			try{
				Native.IOHIDManagerRegisterDeviceMatchingCallback(
                hidmanager, HandleDeviceAdded, IntPtr.Zero);
            Native.IOHIDManagerRegisterDeviceRemovalCallback(
                hidmanager, HandleDeviceRemoved, IntPtr.Zero);
            Native.IOHIDManagerScheduleWithRunLoop(hidmanager,
                                                          RunLoop, InputLoopMode);

            //Native.IOHIDManagerSetDeviceMatching(hidmanager, DeviceTypes.Ref);
            Native.IOHIDManagerSetDeviceMatchingMultiple(hidmanager, DeviceTypes.typeRef);
            Native.IOHIDManagerOpen(hidmanager, IntPtr.Zero);

            Native.CFRunLoopRunInMode(InputLoopMode, 0.0, true);
			}catch(Exception ex){
				UnityEngine.Debug.LogException(ex);
						}
            //OpenTK.Platform.MacOS.Carbon.Native.CFRunLoopRunInMode(InputLoopMode, 0.0, true);
        }


        /// <summary>
        /// Devices the added.
        /// </summary>
        /// <param name="context">Context.</param>
        /// <param name="res">Res.</param>
        /// <param name="sender">Sender.</param>
        /// <param name="device">Device.</param>
        void DeviceAdded(IntPtr context, IOReturn res, IntPtr sender, IOHIDDeviceRef device)
        {
            if (Native.IOHIDDeviceOpen(device, IntPtr.Zero) == IOReturn.Zero

               && !Devices.ContainsKey(device))
            {

                IntPtr vendor_id = Native.IOHIDDeviceGetProperty(device, Native.CFSTR(Native.IOHIDVendorIDKey));
				IntPtr product_id = Native.IOHIDDeviceGetProperty(device, Native.CFSTR(Native.IOHIDProductIDKey));
				string description = Native.IOHIDDeviceGetProperty(device, Native.CFSTR(Native.IOHIDProductKey)).ToString();




                IDevice joyDevice = null;
               // IDevice<IAxisDetails, IButtonDetails, IDeviceExtension> joyDevice = null;


                //loop thru drivers and attach the driver to device if compatible
                foreach (var driver in __drivers)
                {
                    if ((joyDevice = driver.ResolveDevice(new GenericHIDDevice(_joysticks.Count,vendor_id.ToInt32(), product_id.ToInt32(), device, this, ""))) != null)
                    {
                        _joysticks[device] = joyDevice;
                        joyDevice.Name=description;

                        break;
                    }
                }

                if (joyDevice == null)
                {//set default driver as resolver if no custom driver match device

					joyDevice = defaultDriver.ResolveDevice(new GenericHIDDevice(_joysticks.Count,vendor_id.ToInt32(), product_id.ToInt32(), device, this, ""));//always return true
					joyDevice.Name=description;

					if (joyDevice != null)
                    {
                        _joysticks[device] = joyDevice;
                       
                    }
                        else
				    {
                        Debug.LogWarning("Device PID:" + product_id.ToInt32().ToString() + " VID:" + product_id.ToInt32().ToString() + " not found compatible driver on the system.Removed!");
                    
                    }

                }



            }
        }


        /// <summary>
        /// Devices the removed.
        /// </summary>
        /// <param name="context">Context.</param>
        /// <param name="res">Res.</param>
        /// <param name="sender">Sender.</param>
        /// <param name="device">Device.</param>
        void DeviceRemoved(IntPtr context, IOReturn res, IntPtr sender, IOHIDDeviceRef device)
        {
            if (Native.IOHIDDeviceConformsTo(device, Native.HIDPage.GenericDesktop, Native.HIDUsageGD.Joystick)
                 || Native.IOHIDDeviceConformsTo(device, Native.HIDPage.GenericDesktop, Native.HIDUsageGD.GamePad)
                 || Native.IOHIDDeviceConformsTo(device, Native.HIDPage.GenericDesktop, Native.HIDUsageGD.MultiAxisController)
             && Devices.ContainsKey(device))
            {
                UnityEngine.Debug.Log(String.Format("Joystick device {0:x} disconnected, sender is {1:x}", device, sender));
                Devices.Remove(device);

            }


		    
           // Native.IOHIDDeviceRegisterInputValueCallback(device, IntPtr.Zero, IntPtr.Zero);
           // Native.IOHIDDeviceUnscheduleWithRunLoop(device, RunLoop, InputLoopMode);
        }


        #endregion








#region IntPtrEqualityComparer
        // Simple equality comparer to allow IntPtrs as keys in dictionaries
        // without causing boxing/garbage generation.
        // Seriously, Microsoft, shouldn't this have been in the BCL out of the box?
        class IntPtrEqualityComparer : IEqualityComparer<IntPtr>
        {
            public bool Equals(IntPtr x, IntPtr y)
            {
                return x == y;
            }

            public int GetHashCode(IntPtr obj)
            {
                return obj.GetHashCode();
            }
        }
        #endregion

#region JoystickDevicesCollection

        /// <summary>
        /// Defines a collection of JoystickAxes.
        /// </summary>
        public sealed class JoystickDevicesCollection : IDeviceCollection
        {
#region Fields
            readonly Dictionary<IntPtr, IDevice> JoystickDevices;
            //readonly Dictionary<IntPtr, IDevice<IAxisDetails, IButtonDetails, IDeviceExtension>> JoystickDevices;

            //readonly List<IntPtr> JoystickIndexToDevice;
            readonly Dictionary<int, IntPtr> JoystickIDToDevice;

            List<IDevice> _iterationCacheList;
            bool _isEnumeratorDirty = true;

            #endregion

#region Constructors

            internal JoystickDevicesCollection()
            {
                JoystickDevices = new Dictionary<IntPtr, IDevice>(new IntPtrEqualityComparer());
                //JoystickDevices = new Dictionary<IntPtr, IDevice<IAxisDetails, IButtonDetails, IDeviceExtension>>(new IntPtrEqualityComparer());
               // JoystickIndexToDevice = new List<IntPtr>();
                JoystickIDToDevice = new Dictionary<int, IntPtr>();

				
            }

            #endregion

#region Public Members

#region IDeviceCollection implementation

            public void Remove(IntPtr device)
            {
                JoystickIDToDevice.Remove(JoystickDevices[device].ID);
                JoystickDevices.Remove(device);
            }


            public void Remove(int inx)
            {
                IntPtr device = JoystickIDToDevice[inx];
                JoystickIDToDevice.Remove(inx);
                JoystickDevices.Remove(device);
            }








            public IDevice this[int ID]
            //public IDevice<IAxisDetails, IButtonDetails, IDeviceExtension> this[int index]
            {
                get { return JoystickDevices[JoystickIDToDevice[ID]]; }
                //				internal set { 
                //
                //							JoystickIndexToDevice [JoystickDevices.Count]=
                //							JoystickDevices[]
                //						}
            }

            public IDevice this[IntPtr device]
            //public IDevice<IAxisDetails, IButtonDetails, IDeviceExtension> this[IntPtr device]
            {
                get { return JoystickDevices[device]; }
                internal set
                {
                    JoystickIDToDevice[value.ID] = device;
                    JoystickDevices[device] = value;

                }
            }


			public bool ContainsKey (int key)
			{ 
              
				return JoystickIDToDevice.ContainsKey(key);
			}



            public bool ContainsKey(IntPtr key)
            {
                return JoystickDevices.ContainsKey(key);
            }


            public System.Collections.IEnumerator GetEnumerator()
            {
                if (_isEnumeratorDirty)
                {
                    _iterationCacheList = JoystickDevices.Values.ToList<IDevice>();
                    _isEnumeratorDirty = false;

                    
                }

                return _iterationCacheList.GetEnumerator();
            }


            /// <summary>
            /// Gets a System.Int32 indicating the available amount of JoystickDevices.
            /// </summary>
            public int Count
            {
                get { return JoystickDevices.Count; }
            }

            #endregion

            #endregion

           
        }
        #endregion;




        void IDisposable.Dispose()
        {
            throw new NotImplementedException();
        }
    }
}

#endif